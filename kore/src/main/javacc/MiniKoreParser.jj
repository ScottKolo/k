// Copyright (c) 2015-2016 K Team. All Rights Reserved.
options {
  STATIC = false;
  UNICODE_INPUT = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
  // FORCE_LA_CHECK = true; // Useful for development, but causes a warning in Production()
}

PARSER_BEGIN(MiniKoreParser)
package org.kframework.parser.minikore;


import java.io.StringReader;
import java.util.*;
import static org.kframework.Collections.*;
import scala.collection.Seq;
import org.kframework.minikore.MiniKore.*;
public class MiniKoreParser {
	public static Definition parse(String definition) throws ParseException{
	    MiniKoreParser parser = new MiniKoreParser(new StringReader(definition));
	    return parser.parseDefinition();
	}


}
PARSER_END(MiniKoreParser)

SKIP :
{
	" "
|	"\t"
|	"\r"
|	"\n"
}

TOKEN : {
       <LSQUARE : "[" >
     | <RSQUARE : "]" >
     | <COLON : ":">
     | <COLONCOLONEQUALS : "::=">
     | <LPAREN : "(">
     | <RPAREN : ")">
     | <MODULE : "module">
     | <ENDMODULE : "endmodule">
     | <IMPORTS: "imports">
     | <SYNTAX : "syntax">
     | <RULE : "rule">
     | <AXIOM : "axiom">
     | <TRUE : "\\true">
     | <FALSE : "\\false">
     | <AND : "\\and">
     | <OR : "\\or">
     | <NOT: "\\not">
     | <IMPLIES: "\\implies">
     | <EXISTS: "\\exists">
     | <FORALL: "\\forall">
     | <NEXT: "\\next">
     | <REWRITE: "\\rewrite">
     | <EQUAL: "\\equal">
     | <ID : (["A" - "Z", "a" - "z", "0" - "9"])+>
     | <COMMA: ",">
     | <VARSTRING: (["A" - "Z"])+ (["A" - "Z", "a" - "z", "0" - "9"])*>
     | <SORT : (["A" - "Z", "a" - "z", "0" - "9"])+>
     | <SYMBOL : (["A" - "Z", "a" - "z", "0" - "9", "#"])+>
}

<STRING_STATE> TOKEN :
{
    <STRING : (~["\"", "[", "]", " "])+>
}

Definition parseDefinition():
{
    Seq<Module> modules;
    Seq<Pattern> att;
}
{
    (att = attributes()) (modules = modules())
    {
        return new Definition(modules, att);
    }

}

Seq<Module> modules():
{
    Module m1;
    Seq<Module> m2;
    List<Module> m3;
}
{
    <EOF> {return immutable(new ArrayList());}
    | LOOKAHEAD(2)
      (m1 = module()) (m2 = modules ()) {m3 = mutable(m2); m3.add(m1); return immutable(m3);}
    | (m1 = module()) {return immutable(new ArrayList().add(m1));}
}


Seq<Pattern> attributes():
{
    Seq<Pattern> patterns;
    List<Pattern> patternList;
    Pattern p;
}
{

      LOOKAHEAD(3)
      <LSQUARE> (p = pattern()) <COMMA> (patterns = patterns())+ <RSQUARE> {patternList = mutable(patterns); patternList.add(p); return immutable(patternList);}
    | LOOKAHEAD(2)
      <LSQUARE> (p = pattern()) <RSQUARE> {return immutable(new ArrayList().add(p));}
    | <LSQUARE> <RSQUARE> {return immutable(new ArrayList());}

}

Module module():
{
    Token id;
    String name;
    Seq<Sentence> sentences;
    Seq<Pattern> att;
}
{
      LOOKAHEAD(2)
       <MODULE> (id = <ID>) <ENDMODULE> (att = attributes()) {return new Module(id.image, immutable(new ArrayList()), att);}
     | <MODULE> (id = <ID>) (sentences = sentences()) <ENDMODULE> (att = attributes()) {return new Module(id.image, sentences, att);}
}

Seq<Pattern> patterns():
{
    Seq<Pattern> patterns;
    List<Pattern> patternList;
    Pattern p;
}
{
    LOOKAHEAD(2)
     (p = pattern()) <COMMA> (patterns = patterns()) {patternList = mutable(patterns); patternList.add(p); return immutable(patternList);}
    | (p = pattern()) {return immutable(new ArrayList().add(p));}
}

Pattern pattern():
{
    Token varstring;
    Token sort;
    Token symbol;
    Token string;
    Seq<Pattern> patterns;
    Pattern p1;
    Pattern p2;
}
{
    (varstring = <VARSTRING>) <COLON> (sort = <SORT>) {return new Variable(varstring.image, sort.image);}
    | LOOKAHEAD(2)
    (symbol = <SYMBOL>) <LPAREN> (patterns = patterns()) <RPAREN> {return new Application(symbol.image, patterns);}
    | (symbol = <SYMBOL>) <LPAREN> (string = <STRING>) <RPAREN> {return new DomainValue(symbol.image, string.image);}
    | <TRUE> <LPAREN> <RPAREN> {return new True();}
    | <FALSE> <LPAREN> <RPAREN> {return new False();}
    | <AND> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new And(p1, p2);}
    | <OR> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Or(p1, p2);}
    | <NOT> <LPAREN> (p1 = pattern()) <RPAREN> {return new Not(p1);}
    | <IMPLIES> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Implies(p1, p2);}
    | <EXISTS> <LPAREN> (varstring = <VARSTRING>) <COLON> <COMMA> (sort = <SORT>) (p1 = pattern()) <RPAREN> {return new Exists(new Variable(varstring.image, sort.image), p1);}
    | <FORALL> <LPAREN> (varstring = <VARSTRING>) <COLON> <COMMA> (sort = <SORT>) (p1 = pattern()) <RPAREN> {return new ForAll(new Variable(varstring.image, sort.image), p1);}
    | <NEXT> <LPAREN> (p1 = pattern()) <RPAREN> {return new Next(p1);}
    | <REWRITE> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Rewrite(p1, p2);}
    | <EQUAL> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Equal(p1, p2);}
}

Seq<Sentence> sentences():
{
    Seq<Sentence> sentences;
    List<Sentence> sentenceList;
    Sentence s;
}
{
    LOOKAHEAD(2)
      (s = sentence()) (sentences = sentences()) {sentenceList = mutable(sentences); sentenceList.add(s); return immutable(sentenceList);}
    | (s = sentence()) {return immutable(new ArrayList().add(s));}
}

Sentence sentence():
{
    Token name;
    Token sort;
    Token label;
    Seq<Pattern> att;
    Seq<String> sorts;
    Pattern p;
}
{

      <IMPORTS> (name = <VARSTRING>) (att = attributes()) {return new Import(name.image, att);}
    | LOOKAHEAD(3)
    <SYNTAX> (sort = <SORT>) <COLONCOLONEQUALS> (label = <SYMBOL>) <LPAREN> (sorts = sorts()) <RPAREN> (att = attributes()) {return new SymbolDeclaration(sort.image, label.image, sorts, att);}
    | <SYNTAX> (sort = <SORT>) (att = attributes()) {return new SortDeclaration(sort.image, att);}
    | <RULE> (p = pattern()) (att = attributes()) {return new Rule(p, att);}
    | <AXIOM> (p = pattern()) (att = attributes()) {return new Axiom(p, att);}
}

Seq<String> sorts():
{
    List<String> sortList;
    Seq<String> sorts;
    Token sort;
}
{
    LOOKAHEAD(2)
      (sort = <SORT>) <COMMA> (sorts = sorts()) {sortList = mutable(sorts); sortList.add(sort.image); return immutable(sortList);}
    | (sort = <SORT>) {return immutable(new ArrayList().add(sort.image));}
}
