// Copyright (c) 2015-2016 K Team. All Rights Reserved.
options {
  STATIC = false;
  UNICODE_INPUT = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
  // FORCE_LA_CHECK = true; // Useful for development, but causes a warning in Production()
}

PARSER_BEGIN(MiniKoreParser)
package org.kframework.parser.minikore;


import java.io.StringReader;
import java.util.*;
import static org.kframework.Collections.*;
import scala.collection.Seq;
import org.kframework.minikore.MiniKore.*;
public class MiniKoreParser {
	public static Definition parse(String definition) throws ParseException{
	    MiniKoreParser parser = new MiniKoreParser(new StringReader(definition));
	    return parser.parseDefinition();
	}


}
PARSER_END(MiniKoreParser)

SKIP :
{
	" "
|	"\t"
|	"\r"
|	"\n"
}

TOKEN : {
       <LSQUARE : "[" >
     | <RSQUARE : "]" >
     | <COLON : ":">
     | <COLONCOLONEQUALS : "::=">
     | <LPAREN : "(">
     | <RPAREN : ")">
     | <MODULE : "module">
     | <ENDMODULE : "endmodule">
     | <IMPORTS: "imports">
     | <SYNTAX : "syntax">
     | <RULE : "rule">
     | <AXIOM : "axiom">
     | <TRUE : "\\true">
     | <FALSE : "\\false">
     | <AND : "\\and">
     | <OR : "\\or">
     | <NOT: "\\not">
     | <IMPLIES: "\\implies">
     | <EXISTS: "\\exists">
     | <FORALL: "\\forall">
     | <NEXT: "\\next">
     | <REWRITE: "\\rewrite">
     | <EQUAL: "\\equal">
     | <MODULENAME: (["A" - "Z"]) (["A" - "Z", "-"])*>
     | <ID : (["A" - "Z"]) (["a" - "z", "A" - "Z"])*>
     | <SYMBOL : (["a" - "z", "$", "#", "@", "%", "^", "_"])(["A" - "Z", "a" - "z", "0" - "9", "_", "$", "#", "@", "%", "^", "_"])*>
     | <COMMA: ",">
     | <STRING: "\"" (~["\""])+ "\"">
}


Definition parseDefinition():
{
    Seq<Module> modules;
    Seq<Pattern> att;
}
{
    (att = attributes()) (modules = modules())
    {
        return new Definition(modules, att);
    }

}

Seq<Module> modules():
{
    Module m1;
    Seq<Module> m2;
    List<Module> m3;
}
{
    <EOF> {return immutable(new ArrayList());}
    | LOOKAHEAD(2)
      (m1 = module()) (m2 = modules ()) {m3 = mutable(m2); m3.add(0, m1); return immutable(m3);}
    | (m1 = module()) {m3 = new ArrayList(); m3.add(0, m1); return immutable(m3);}
}


Seq<Pattern> attributes():
{
    Seq<Pattern> patterns;
}
{
        LOOKAHEAD(2)
        <LSQUARE> <RSQUARE> {return immutable(new ArrayList());}
      | <LSQUARE> patterns = patterns() <RSQUARE> {return patterns;}

}

Module module():
{
    Token id;
    String name;
    Seq<Sentence> sentences;
    Seq<Pattern> att;
}
{
       LOOKAHEAD(3)
       <MODULE> (id = <MODULENAME>) (sentences = sentences()) <ENDMODULE> (att = attributes()) {return new Module(id.image, sentences, att);}
     | LOOKAHEAD(3)
       <MODULE> (id = <MODULENAME>) <ENDMODULE> (att = attributes()) {return new Module(id.image, immutable(new ArrayList()), att);}
}

Seq<Pattern> patterns():
{
    Seq<Pattern> patterns = null;
    List<Pattern> returnList;
    Pattern p;
}
{
    (p = pattern()) (<COMMA> patterns = patterns())?  {if (patterns != null) {returnList = mutable(patterns); returnList.add(p); return immutable(returnList);} returnList = new ArrayList(); returnList.add(p); return immutable(returnList);}
}


Variable variable():
{
    Token name;
    Token sort;
}
{
    (name = <ID> | name = <MODULENAME> ) <COLON> (sort = <ID> | sort = <MODULENAME>) {return new Variable(name.image, sort.image);}
}
Pattern pattern():
{
    Variable v;
    Token sort;
    Token symbol;
    Token string = null;
    Seq<Pattern> patterns;
    Pattern p1;
    Pattern p2;
}
{
      (v = variable()) {return v;}
    | LOOKAHEAD(3)
      (symbol = <SYMBOL>) <LPAREN> (string = <STRING>)? <RPAREN> {if (string != null) return new DomainValue(symbol.image, string.image); return new Application(symbol.image, immutable(new ArrayList()));}
    | (symbol = <SYMBOL>) <LPAREN> (patterns = patterns()) <RPAREN> {return new Application(symbol.image, patterns);}
    | <TRUE> <LPAREN> <RPAREN> {return new True();}
    | <FALSE> <LPAREN> <RPAREN> {return new False();}
    | <AND> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new And(p1, p2);}
    | <OR> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Or(p1, p2);}
    | <NOT> <LPAREN> (p1 = pattern()) <RPAREN> {return new Not(p1);}
    | <IMPLIES> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Implies(p1, p2);}
    | <EXISTS> <LPAREN> (v = variable()) <COMMA> (p1 = pattern()) <RPAREN> {return new Exists(v , p1);}
    | <FORALL> <LPAREN> (v = variable()) <COMMA> (p1 = pattern()) <RPAREN> {return new ForAll(v , p1);}
    | <NEXT> <LPAREN> (p1 = pattern()) <RPAREN> {return new Next(p1);}
    | <REWRITE> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Rewrite(p1, p2);}
    | <EQUAL> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return new Equal(p1, p2);}
}

Seq<Sentence> sentences():
{
    Seq<Sentence> sentences;
    List<Sentence> sentenceList;
    Sentence s = null;
}
{
         LOOKAHEAD(2)
         (s = sentence()) (sentences = sentences()) {sentenceList = mutable(sentences); sentenceList.add(0, s); return immutable(sentenceList);}
       | (s = sentence())? {sentenceList = new ArrayList(); if(s != null) { sentenceList.add(0, s);} return immutable(sentenceList);}
}

Sentence sentence():
{
    Token name;
    Token sort;
    Token label;
    Seq<Pattern> att;
    Seq<String> sorts;
    Pattern p;
}
{

      <IMPORTS> (name = <MODULENAME>) (att = attributes()) {return new Import(name.image, att);}
    | LOOKAHEAD(3)
    <SYNTAX> (sort = <ID> | sort = <MODULENAME>) <COLONCOLONEQUALS> (label = <SYMBOL>) <LPAREN> (sorts = sorts()) <RPAREN> (att = attributes()) {return new SymbolDeclaration(sort.image, label.image, sorts, att);}
    | <SYNTAX> (sort = <ID> | sort = <MODULENAME>) (att = attributes()) {return new SortDeclaration(sort.image, att);}
    | <RULE> (p = pattern()) (att = attributes()) {return new Rule(p, att);}
    | <AXIOM> (p = pattern()) (att = attributes()) {return new Axiom(p, att);}
}

Seq<String> sorts():
{
    List<String> sortList;
    Seq<String> sorts;
    Token sort = null;
}
{
    LOOKAHEAD(2)
      (sort = <ID> | sort = <MODULENAME> ) <COMMA> (sorts = sorts()) {sortList = mutable(sorts); sortList.add(0, sort.image); return immutable(sortList);}
    | (sort = <ID> | sort = <MODULENAME>)? {sortList = new ArrayList(); if(sort != null) sortList.add(0, sort.image); return immutable(sortList);}
}
