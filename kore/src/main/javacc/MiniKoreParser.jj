// Copyright (c) 2015-2016 K Team. All Rights Reserved.
// Represents the grammar of the KSEQ module in kast.k
options {
  STATIC = false;
  UNICODE_INPUT = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
  TOKEN_MANAGER_USES_PARSER = true;
  // FORCE_LA_CHECK = true; // Useful for development, but causes a warning in Production()
}

PARSER_BEGIN(MiniKoreParser)
package org.kframework.parser.minikore;


import org.kframework.minikore.MiniKore.*;
import java.io.StringReader;
import java.util.*;

public class MiniKoreParser {
	public static Definition parse(String definition) throws ParseException{
	    MiniKoreParser parser = new MiniKoreParser(new StringReader(definition));
	    return parser.parseDefinition();
	}


}
PARSER_END(MiniKoreParser)

SKIP :
{
	" "
|	"\t"
|	"\r"
|	"\n"
}

TOKEN :
{
      <LSQUARE : "[" >
    | <RSQUARE : "]" >
    | <EMPTYATT: ("[")("]") >
    | <COLON : ":">
    | <COLONCOLONEQUALS : "::=">
    | <LPAREN : "(">
    | <RPAREN : ")">
    | <MODULE : "module">
    | <ENDMODULE : "endmodule">
    | <IMPORTS: "imports">
    | <SYNTAX : "syntax">
    | <RULE : "rule">
    | <AXIOM : "axiom">
    | <TRUE : "\\true">
    | <FALSE : "\\false">
    | <AND : "\\and">
    | <OR : "\\or">
    | <NOT: "\\not">
    | <IMPLIES: "\\implies">
    | <EXISTS: "\\exists">
    | <FORALL: "\\forall">
    | <NEXT: "\\next">
    | <REWRITE: "\\rewrite">
    | <EQUAL: "\\equal">
    | <COMMA: ",">
    | <VARSTRING: (["A" - "Z"])+ (["A" - "Z", "a" - "z", "0" - "9"])*>
    | <SORT : (["A" - "Z", "a" - "z", "0" - "9"])+>
    | <SYMBOL : (["A" - "Z", "a" - "z", "0" - "9", "#"])+>
    | <ID : (["A" - "Z", "a" - "z", "0" - "9"])+>
    | <STRING : (~["\""])+>

}

Definition parserDefinition():
{
    List<Module> modules;
    Attributes att;
}
{
    (att = attributes()) (modules = modules())
    {
        return Definition.apply(modules, att);
    }

}

List<Module> modules():
{
    List<Module> modules;
    Module m1;
}
{
    LOOKAHEAD(2)
    (m1 = module()) (m2 = modules ())? {return m2.add(m1);}
    | (m1 = module()) {return new ArrayList().add(m1);}
}


Attributes attributes():
{
    List<Pattern> patterns;
    Pattern p;
}
{
    LOOKAHEAD(2)
    <LSQUARE> (p = pattern()) <COMMA> (patterns = patterns())+ <RSQUARE> {return patterns.add(pattern);}
    | <LSQUARE> (p = pattern()) <RSQUARE> {return new ArrayList().add(p);}
    | <EMPTYATT> {return new ArrayList();}
}

Module module():
{
    Token id;
    String name;
    List<Sentence> sentences;
    Attribute att;
}
{
    <MODULE> (id = <ID>) (sentences = sentences()) <ENDMODULE> (att = attributes())
    {return Module.apply(id.image, sentences, att);}
}

List<Pattern> patterns():
{
    List<Pattern> patterns;
    Pattern pattern;
}
{
    LOOKAHEAD(2)
     (p = pattern()) <COMMA> (patterns = patterns()) {return patterns.add(pattern);}
    | p = pattern() {return new ArrayList().add(p);}
}

Pattern pattern():
{
    Token varstring;
    Token sort;
    Token symbol;
    Token string;
    List<Pattern> patterns;
    Pattern p1;
    Pattern p2;
}
{
    (varstring = <VARSTRING>) <COLON> (sort = <SORT>) {return Variable.apply(varstring.image, sort.image);}
    | LOOKAHEAD(2)
    (symbol = <SYMBOL>) <LPAREN> (patterns = patterns()) <RPAREN> {return Application.apply(symbol.image, patterns);}
    | (symbol = <SYMBOL>) <LPAREN> (string = <STRING>) <RPAREN> {return DomainValue.apply(symbol.image, string.image);}
    | <TRUE> <LPAREN> <RPAREN> {return True.apply();}
    | <FALSE> <LPAREN> <RPAREN> {return False.apply();}
    | <AND> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return And.apply(p1, p2);}
    | <OR> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return Or.apply(p1, p2);}
    | <NOT> <LPAREN> (p1 = pattern()) <RPAREN> {return Not.apply(p1);}
    | <IMPLIES> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return Implies.apply(p1, p2);}
    | <EXISTS> <LPAREN> (varstring = <VARSTRING>) (p1 = pattern()) <RPAREN> {return Exists.apply(varstring.image, p1);}
    | <FORALL> <LPAREN> (varstring = <VARSTRING>) (p1 = pattern()) <RPAREN> {return ForAll.apply(varstring.image, p1);}
    | <NEXT> <LPAREN> (p1 = pattern()) <RPAREN> {return Not.apply(p1);}
    | <REWRITE> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return Rewrite.apply(p1, p2);}
    | <EQUAL> <LPAREN> (p1 = pattern()) <COMMA> (p2 = pattern()) <RPAREN> {return Equal.apply(p1, p2);}
}

List<Sentence> sentences():
{
    List<Sentence> sentences;
    Sentence sentence;
}
{
    LOOKAHEAD(2)
      (s = sentence()) (sentences = sentences()) {return sentences.add(sentence);}
    | (s = sentence()) {return new ArrayList().add(s);}
}

Sentence sentence():
{
    Token name;
    Token sort;
    Token label;
    Attributes att;
    List<String> sorts;
    Pattern p;
}
{

      <IMPORTS> (name = <VARSTRING>) (att = attributes()) {return Import.apply(name.image, att);}
    | LOOKAHEAD(3)
    <SYNTAX> (sort = <SORT>) <COLONCOLONEQUALS> (label = <SYMBOL>) <LPAREN> (sorts = sorts()) <RPAREN> (att = attributes()) {return SymbolDeclaration.apply(sort.image, label.image, sorts, attributes);}
    | <SYNTAX> (sort = <SORT>) (att = attributes()) {return SortDeclaration.apply(sort.image, att);}
    | <RULE> (p = pattern()) (att = attributes()) {return Rule.apply(p, att);}
    | <AXIOM> (p = pattern()) (att = attributes()) {return Axiom.apply(p, att);}
}

List<String> sorts():
{
    List<String> sorts;
    Token sort;
}
{
    LOOKAHEAD(2)
      (sort = <SORT>) <COMMA> (sorts = sorts()) {return sorts.add(sort.image);}
    | (sort = <SORT>) {return new ArrayList().add(sort.image);}
}
